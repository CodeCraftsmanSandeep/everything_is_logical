| Class | problem | notes | status |
|:--------|:---|:---------|:--------|
| Binary | Sum of Two integers without using arthimetic operators | [useful article](https://leetcode.com/problems/sum-of-two-integers/solutions/84278/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently/) |âœ…|
| dp | 1) [Climbing stairs](https://leetcode.com/problems/climbing-stairs/description/) | [my code](climbing_stairs.cpp) | âœ… |
| | 2) [Coin change](https://leetcode.com/problems/coin-change/) | [my code](coin_change.cpp) | âœ… |
| | 3) Longest Increasing Subsequence | Need to do using BIT tree | pending approaches |
| | 4) Longest Common Subsequence | | âœ… |
| | 5) Word break | [my code](word_break.cpp) | âœ… | 
| | 6) Combination sum | [my code](combinationSum.cpp) | âœ… |
| | 7) House robber | [my code](house_robber.cpp), n time, O(1) space | âœ… |
| | 8) House robber 2 | [my code](house_robber2.cpp), 2*n time, O(1) space | âœ… |
| | 9) Decode ways | [my code](decode_ways.cpp), n time, O(1) space is possible but makes code not cleaner, so I used a dummy string in my code | âœ… |
| | 10) Unique paths | [my code](unique_paths.cpp), n + m time, O(1) space, using combinatorics | âœ… |
| | 11) Jump game | [my code](jump_game.cpp), n time, O(1) space | âœ… |
| Graph | 1) Clone graph | [my code](clone_graph.cpp), n+m time, O(n) space | âœ… |
| | 2) Course schedule | [my code](course_schedule.cpp), n+m time, n space |âœ… |
| | 3) **pacific_atlantic_water_flow | [my code](pacific_atlantic_water_flow.cpp), 2*n*m time, O(n*m) space | âœ… |
| | 4) number_of_islands | [my code](number_of_islands.cpp), O(n*m) time, O(n*m) space | âœ… |
| | 5) Longest consecutive subsequence | [my code](longest_consecutive_subsequence.cpp), O(n) time (taking hashing: O(1)), O(n) space | âœ… |
| | 6) **[Alien dictionary](https://www.geeksforgeeks.org/problems/alien-dictionary/1) | [my code](alien_dictionary.cpp), O(k + n) space, O(k + n) time | âœ… |
| | 7) [Graph valid tree](https://www.geeksforgeeks.org/problems/is-it-a-tree/1) | [my code](graph_valid_tree.cpp), O(n + m) time (assuming time complexity for merge in union-find using path compression is constant time), O(n) space | âœ… |
| | 8) Number of connected compoentns | i) can be done using union find <br/> ii) doing dfs for every unvisited vertices |  âœ… | 

<!-- 
ðŸ”²
-->


